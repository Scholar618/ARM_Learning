@ 汇编中的符号
	@ 1.指令：能够编译生成一条32bits机器码，并且能够直接被CPU识别和执行
	@ 2.伪指令：本身不是指令，但是编译器可以将其替换若干条指令
	@ 3.伪操作：不会生成指令，只是在编译阶段会告诉编译器怎么编译
	
@ ARM指令集
	@ 1.数据处理指令：	进行数学运算和逻辑运算
	@ 2.跳转指令：		实现程序的跳转，本质就是修改了PC寄存器
	@ 3.Load/Store指令：访问（读写）内存，
	@ 4.状态寄存器传送指令：用于访问（读写）CPSR寄存器
	@ 5.软中断指令：	触发软中断
	@ 6.协处理器指令：	操作协处理器的指令
	
@ ******************************************************************
	
.text			@ 表示当前为代码段
.global _start	@ 将start定义为全局符号
_start:			@ 汇编的入口
@ 1.指令：能够编译生成一条32bits机器码，并且能够直接被CPU识别和执行
	@ 1.1 数据处理指令：进行数学运算和逻辑运算
	
	@ 数据搬移指令	
	@ MOV R1,#1	@ 汇编指令
	@ MOV R2,#2
	@ MOV R3,R1
	@ MOV PC,#4
	
	@ MVN R0,#0xFF
	@ R0 = ~0xFF
	
	@ MOV R0, #0
	@ MVN R0, #0
	
	@ 立即数
	@ 立即数的本质就是包含在指令当中的数，属于指令的一部分
	@ 立即数的优点：
	@		取指时就可以读取到CPU，不用单独去内存读取，速度快
	@ 立即数的缺点：
	@		不能是任意的32位数字，有局限性
	@ MOV R0, 0x12345678	@ 不是立即数
	@ MOV R0, 0x12			@ 是立即数
	
	@ 伪指令
	@ MOV R0, 0xFFFFFFFF
	
	@ 数据运算指令格式
	@	（操作码） （目标寄存器） （第一操作寄存器） （第二操作数）
	@		操作码：		表示执行哪种操作
	@		目标寄存器：	用于存储运算的结果
	@		第一操作寄存器：存储第一个参与运算的数据（只能写寄存器）
	@		第二操作数：	第二个参与运算的数据（可以是寄存器也可以是立即数）
	
	@ 加法指令
	@ MOV R1, #5
	@ MOV R2, #3
	@ ADD R1, R2, R3
	@ R1 = R2 + R3
	@ ADD R1, R2, #5
	@ R1 = R2 + 5
	
	@ 减法指令
	@ SUB R1, R2, R3	
	@ R1 = R2 - R3
	@ SUB R1, R2, #4
	@ R1 = R2 - 4
	
	@ 逆向减法指令
	@ RSB R1, R2, #3
	@ R1 = 3 - R2
	
	@ 乘法指令
	@ MUL R1, R2, R3
	@ R1 = R2 * R3
	@ 乘法指令只能是两个寄存器相乘，不能有立即数
	
	@ 按位与指令（有0则0，无0才1）
	@ AND R1, R2, R3
	@ R1 = R2 & R3
	
	@ 按位或指令（有1则1，无1才0）
	@ ORR R1, R2, R3
	@ R1 = R2 | R3
	
	@ 按位异或指令（相同为0，相异为1）
	@ EOR R1, R2, R3
	@ R1 = R2 ^ R3
	
	@ 左移指令（R1 = R2向左移R3位）
	@ LSL R1, R2, R3
	@ R1 = (R2 << R3)
	
	@ 右移指令（R1 = R2向右移R3位）
	@ LSR R1, R2, R3
	@ R1 = (R2 >> R3)
	
	@ 位清零指令
	@ BIC R1, R2, #0xF
	@ 第二操作数哪一位为1，就将第一操作寄存器中的哪一位清零，然后将结果放入目标寄存器中
	
	@ 数据运算指令扩展
	@ 遇到这种情况，将后面几个操作码看作一个整体。
	@ MOV R1, R2, LSL, #1
	@ R1 = (R2 << 1)
	
	@ 数据运算指令对条件位（N、Z、C、V）的影响
	@ 默认情况下，数据运算不会对条件位产生影响，
	@ 当在指令后面加后缀“S”可以影响
	@ MOV R1 ,#3
	@ SUBS R2, R1, #5
	
	@ 带进位的加法指令
	
	@ 两个64位的数据做加法运算
	@ 第一个低32位放到R1
	@ 第一个高32位放到R2
	@ 第二个低32位放到R3
	@ 第二个高32位放到R4
	@ 运算结果低32位放到R5
	@ 运算结果高32位放到R6
	
	@ 第一个数
	@ 0x00000002	00000001
	@ 第二个数
	@ 0x00000001	00000005
	
	@ MOV R1, #0x00000001
	@ MOV R2, #0x00000002
	@ MOV R3, #0x00000005
	@ MOV R4, #0x00000001
	@ ADDS R5, R1, R3
	@ ADC R6, R2, R4
	@ 本质：R6 = R2 + R4 + 'C'
	
	@ 带借位的减法指令
	
	@ 第一个数
	@ 0x00000002	00000001
	@ 第二个数
	@ 0x00000001	00000005
	
	MOV R1, #0x00000001
	MOV R2, #0x00000002
	MOV R3, #0x00000005
	MOV R4, #0x00000001
	SUBS R5, R1, R3
	SUB	 R6, R2, R4	
	@ 本质：R6 = R2 - R4 - '!C'
	
	
	

stop:			@ 死循环防止跑飞
	B stop

.end			@ 汇编的结束

